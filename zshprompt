function git_info {
    return;
    zgit_isgit || return

    #if ! zgit_isindexclean; then
    #    echo -n "${GREEN}+"
    #fi

    echo -n "${RED}"
    #if ! zgit_isworktreeclean; then
    #    echo -n '!'
    #fi
    #if zgit_hasunmerged; then
    #    echo -n '*'
    #fi
    #if zgit_hasuntracked; then
    #    echo -n '?'
    #fi
}

function git_path {
    if zgit_isgit; then
        wd=$(pwd)
        cdup=$(git rev-parse --show-cdup)
        if [ -z "$cdup" ]; then cdup="."; fi
        cd $cdup
        name=$(pwd)

        if zgit_isworktreeclean; then
            if zgit_isindexclean; then
                color=$GREEN
            else
                color=$YELLOW
            fi
        else
            color=$RED
        fi
        cd $wd
        echo ${${${$(print -P %d)/${name}/${name:h}/${color}${name:t}${CYAN}}/${HOME}/\~/}/\/\//\/} $(scm_status)
    else
        echo $(print -P %~)
    fi
}

pluralize() {
    if (( $1 > 1 )); then
        echo 's';
    fi
}
scm_status() {
	zgit_isgit || return
	local -A pc
	pc=(${(kv)wunjo_prompt_colors})

	head=$(zgit_head)
	gitcommit=$(revstring $head)

	local -a commits

	if zgit_rebaseinfo; then
		orig_commit=$(revstring $zgit_info[rb_head])
		orig_name=$(git name-rev --name-only $zgit_info[rb_head])
		orig="$pc[scm_branch]$orig_name$pc[punc]($pc[scm_commitid]$orig_commit$pc[punc])"
		onto_commit=$(revstring $zgit_info[rb_onto])
		onto_name=$(git name-rev --name-only $zgit_info[rb_onto])
		onto="$pc[scm_branch]$onto_name$pc[punc]($pc[scm_commitid]$onto_commit$pc[punc])"

		if [[ -n "$zgit_info[rb_upstream]" ]] && [[ $zgit_info[rb_upstream] != $zgit_info[rb_onto] ]]; then
			upstream_commit=$(revstring $zgit_info[rb_upstream])
			upstream_name=$(git name-rev --name-only $zgit_info[rb_upstream])
			upstream="$pc[scm_branch]$upstream_name$pc[punc]($pc[scm_commitid]$upstream_commit$pc[punc])"
			commits+="rebasing $upstream$pc[reset]..$orig$pc[reset] onto $onto$pc[reset]"
		else
			commits+="rebasing $onto$pc[reset]..$orig$pc[reset]"
		fi

		local -a revs
		revs=($(git rev-list $zgit_info[rb_onto]..HEAD))
		if [[ $#revs -gt 0 ]]; then
			commits+="\n$#revs commit$(pluralize $#revs) in"
		fi

		if [[ -f $zgit_info[dotest]/message ]]; then
			mess=$(head -n1 $zgit_info[dotest]/message)
			commits+="on $mess"
		fi
	elif [ -n "$gitcommit" ]; then
		commits+="on $pc[scm_branch]$head$pc[punc]($pc[scm_commitid]$gitcommit$pc[punc])$pc[reset]"
		local track_merge=$(zgit_tracking_merge)
		if [[ -n "$track_merge" ]]; then
			if git rev-parse --verify -q $track_merge >/dev/null; then
				local track_remote=$(zgit_tracking_remote)
				local tracked=$(revstring $track_merge 2>/dev/null)

				local -a revs
				revs=($(git rev-list --reverse $track_merge..HEAD))
				if (( $#revs > 0 )); then
					local base=$(revstring $revs[1]~1)
					local base_name=$(git name-rev --name-only $base)
					local base_short=$(revstring $base)

					local conj="since"
					if [[ "$base" == "$tracked" ]]; then
						conj+=" tracked"
						tracked=
					fi
					commits+="$#revs commit$(pluralize $#revs) $conj $pc[scm_branch]$base_name$pc[punc]($pc[scm_commitid]$base_short$pc[punc])$pc[reset]"
				fi

				if [[ -n "$tracked" ]]; then
					local track_name=$track_merge
					if [[ $track_remote == "." ]]; then
						track_name=${track_name##*/}
					fi
					tracked=$(revstring $tracked)
					commits+="tracking $pc[scm_branch]$track_name$pc[punc]"
					if [[ "$tracked" != "$gitcommit" ]]; then
						commits[$#commits]+="($pc[scm_commitid]$tracked$pc[punc])"
					fi
					commits[$#commits]+="$pc[reset]"
				fi
			fi
		fi
	fi

	if [ $#commits -gt 0 ]; then
		echo -n " ${(j: :)commits}"
	fi
}


PS1='${YELLOW}[%T${CYAN}%1(j.%%${GREEN}%j${CYAN}.)%0(?..:${HIRED}%?)${YELLOW}]${CYAN}$(git_info)${CYAN}%# ${NORM}'
RPS1='${CYAN}%n@%m:$(git_path)${NORM}'
